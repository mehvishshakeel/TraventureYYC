<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Itinerary - TraventureYYC</title>
  <link rel="stylesheet" href="../css/main.css">
</head>
<body>
  <div class="app-container">
    <!-- Status Bar -->
    <div class="status-bar">
      <div class="status-bar__left">
        <div class="status-bar__time">9:41</div>
      </div>
      <div class="status-bar__right">
        <div class="status-bar__signal">
          <img src="../images/mobile-signal-60.svg" alt="Signal">
        </div>
        <div class="status-bar__wifi">
          <img src="../images/wifi-59.svg" alt="WiFi">
        </div>
        <div class="status-bar__battery">
          <img src="../images/rectangle-56.svg" alt="Battery">
          <img src="../images/combined-shape-57.svg" alt="Battery">
          <img src="../images/rectangle-58.svg" alt="Battery">
        </div>
      </div>
    </div>

    <!-- Top Bar -->
    <div class="top-bar">
      <a href="homepage.html" style="color: var(--color-text-black);">‚Üê</a>
      <div class="top-bar__logo">
        Itinerary
      </div>
      <div class="top-bar__actions">
        <a href="itinerary-add.html" style="color: var(--color-primary); font-size: 24px; font-weight: bold;">+</a>
      </div>
    </div>

    <!-- Undo Notification -->
    <div id="undoNotification" class="undo-notification" style="display: none;">
      <div class="undo-notification__content">
        <span class="undo-notification__message">Event deleted</span>
        <button class="undo-notification__button" id="undoButton">Undo</button>
      </div>
    </div>

    <!-- Content -->
    <div class="content itinerary-page">
      <!-- Date Selector Wrapper -->
      <div class="date-selector-wrapper">
        <div class="date-selector" id="dateSelector">
          <!-- Dates will be generated by JavaScript -->
        </div>
      </div>

      <!-- Current Date Display -->
      <div class="current-date-display">
        <h2 id="currentDateDisplay">Tuesday - July 14, 2026</h2>
      </div>

      <!-- Timeline Container -->
      <div class="timeline-container" id="timelineContainer">
        <div class="timeline" id="timeline">
          <!-- Timeline items will be generated by JavaScript -->
        </div>
      </div>
    </div>

    <!-- Bottom Navigation -->
    <div class="bottom-nav">
      <a href="itinerary.html" class="bottom-nav__item active">
        <img src="../images/calendar-39.svg" alt="Itinerary" class="bottom-nav__icon">
        <span class="bottom-nav__label">Itinerary</span>
      </a>
      <a href="homepage.html" class="bottom-nav__item">
        <img src="../images/home-42.svg" alt="Home" class="bottom-nav__icon">
        <span class="bottom-nav__label">Home</span>
      </a>
      <a href="emergency.html" class="bottom-nav__item">
        <img src="../images/icon-emergency-44.png" alt="Emergency" class="bottom-nav__icon">
        <span class="bottom-nav__label">Emergency</span>
      </a>
      <a href="settings.html" class="bottom-nav__item">
        <img src="../images/node-46.png" alt="Settings" class="bottom-nav__icon">
        <span class="bottom-nav__label">Settings</span>
      </a>
    </div>
  </div>

  <script>
    // Load itinerary data from sessionStorage or use default
    let itineraryData = {};
    try {
      const saved = sessionStorage.getItem('itineraryData');
      if (saved) {
        itineraryData = JSON.parse(saved);
      }
    } catch (e) {
      console.error('Error loading itinerary data:', e);
    }

    // Default itinerary data if no saved data exists
    if (!itineraryData['2026-07-14']) {
      itineraryData = {
      '2026-07-11': {
        date: 'Saturday - July 11, 2026',
        events: [
          {
            time: '10:00',
            title: 'Calgary Zoo',
            details: '10:00 - 13:00',
            address: '210 St. George\'s Drive NE, Calgary, AB T2E 7V6'
          },
          {
            time: '14:00',
            title: 'Glenbow Museum',
            details: '14:00 - 16:00',
            address: '130 9 Ave SE, Calgary, AB T2G 0P3'
          }
        ]
      },
      '2026-07-12': {
        date: 'Sunday - July 12, 2026',
        events: [
          {
            time: '09:00',
            title: 'Heritage Park',
            details: '09:00 - 12:00',
            address: '1900 Heritage Dr SW, Calgary, AB T2V 2X3'
          },
          {
            time: '14:00',
            title: 'Olympic Plaza',
            details: '14:00 - 15:00',
            address: '228 8 Ave SE, Calgary, AB T2G 0K6'
          },
          {
            time: '17:00',
            title: 'Calgary Tower',
            details: '17:00 - 19:00',
            address: '101 9 Ave SW, Calgary, AB T2P 1J9'
          }
        ]
      },
      '2026-07-13': {
        date: 'Monday - July 13, 2026',
        events: [
          {
            time: '11:00',
            title: 'Prince\'s Island Park',
            details: '11:00 - 13:00',
            address: '698 Eau Claire Ave SW, Calgary, AB T2P 5N4'
          },
          {
            time: '15:00',
            title: 'Bow River Pathway',
            details: '15:00 - 17:00',
            address: 'Along Bow River, Calgary, AB'
          }
        ]
      },
      '2026-07-14': {
        date: 'Tuesday - July 14, 2026',
        events: [
          {
            time: '10:00',
            title: 'Calgary Zoo',
            details: '10:00 - 13:00',
            address: '210 St. George\'s Drive NE, Calgary, AB T2E 7V6'
          },
          {
            time: '13:00',
            title: 'Peace Bridge',
            details: '13:00 - 14:00',
            address: '98 Memorial Dr NW, Calgary, AB T2N 5C1'
          },
          {
            time: '17:15',
            title: 'Ten Foot Henry',
            details: '17:15 - 19:00',
            address: '1209 1 St SW, Calgary, AB T2R 0V3'
          },
          {
            time: '19:00',
            title: 'Avesta Shawarma',
            details: '19:00 - 20:00',
            address: '698 Eau Claire Ave SW, Calgary, AB T2P 5N4'
          }
        ]
      },
      '2026-07-15': {
        date: 'Wednesday - July 15, 2026',
        events: [
          {
            time: '09:00',
            title: 'Studio Bell',
            details: '09:00 - 11:00',
            address: '850 4 St SE, Calgary, AB T2G 0L8'
          },
          {
            time: '12:00',
            title: 'Stephen Avenue Walk',
            details: '12:00 - 14:00',
            address: 'Stephen Ave, Calgary, AB'
          },
          {
            time: '16:00',
            title: 'Calgary Farmers Market',
            details: '16:00 - 18:00',
            address: '510 77 Ave SE, Calgary, AB T2H 1C3'
          }
        ]
      },
      '2026-07-16': {
        date: 'Thursday - July 16, 2026',
        events: [
          {
            time: '10:00',
            title: 'Fish Creek Provincial Park',
            details: '10:00 - 13:00',
            address: '15979 Bow Bottom Trail SE, Calgary, AB T2J 7A4'
          },
          {
            time: '15:00',
            title: 'Nose Hill Park',
            details: '15:00 - 17:00',
            address: '5620 14 St NW, Calgary, AB T2K 1J7'
          }
        ]
      },
      '2026-07-17': {
        date: 'Friday - July 17, 2026',
        events: [
          {
            time: '11:00',
            title: 'Calgary Stampede',
            details: '11:00 - 18:00',
            address: '1410 Olympic Way SE, Calgary, AB T2G 2W1'
          },
          {
            time: '19:00',
            title: 'Chuckwagon Races',
            details: '19:00 - 21:00',
            address: 'Stampede Park, Calgary, AB'
          }
        ]
      },
      '2026-07-18': {
        date: 'Saturday - July 18, 2026',
        events: [
          {
            time: '10:00',
            title: 'Calgary Stampede',
            details: '10:00 - 17:00',
            address: '1410 Olympic Way SE, Calgary, AB T2G 2W1'
          },
          {
            time: '18:00',
            title: 'Evening Concert',
            details: '18:00 - 21:00',
            address: 'Coca-Cola Stage, Stampede Park'
          }
        ]
      },
      '2026-07-19': {
        date: 'Sunday - July 19, 2026',
        events: []
      },
      '2026-07-20': {
        date: 'Monday - July 20, 2026',
        events: [
          {
            time: '14:00',
            title: 'Shopping at Chinook Centre',
            details: '14:00 - 17:00',
            address: '6455 Macleod Trail SW, Calgary, AB T2H 0K8'
          }
        ]
      }
    };
      
      // Save default data to sessionStorage
      sessionStorage.setItem('itineraryData', JSON.stringify(itineraryData));
    }

    // Function to save itinerary data
    function saveItineraryData() {
      sessionStorage.setItem('itineraryData', JSON.stringify(itineraryData));
    }

    // Generate dates (14 days starting from July 11, 2026)
    function generateDates() {
      const dateSelector = document.getElementById('dateSelector');
      const startYear = 2026;
      const startMonth = 6; // July (0-indexed)
      const startDay = 11;
      const dates = [];
      
      for (let i = 0; i < 14; i++) {
        // Create date using local timezone to avoid timezone issues
        const date = new Date(startYear, startMonth, startDay + i);
        dates.push(date);
      }

      dates.forEach((date, index) => {
        // Format date string manually to ensure consistency
        const year = date.getFullYear();
        const month = date.getMonth() + 1; // getMonth() is 0-indexed
        const day = date.getDate();
        const dateStr = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
        
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const monthName = monthNames[date.getMonth()];
        
        const dateTab = document.createElement('div');
        dateTab.className = 'date-tab';
        dateTab.dataset.date = dateStr;
        if (index === 3) { // July 14 is the default selected date
          dateTab.classList.add('active');
        }
        
        dateTab.innerHTML = `
          <span class="date-tab__day">${day}${getDaySuffix(day)}</span>
          <span class="date-tab__month">${monthName}</span>
        `;
        
        dateSelector.appendChild(dateTab);
      });

      // Set initial date
      updateTimeline('2026-07-14');
    }

    function getDaySuffix(day) {
      if (day > 3 && day < 21) return 'th';
      switch (day % 10) {
        case 1: return 'st';
        case 2: return 'nd';
        case 3: return 'rd';
        default: return 'th';
      }
    }

    // Update timeline based on selected date
    function updateTimeline(dateStr) {
      const timeline = document.getElementById('timeline');
      const timelineContainer = document.getElementById('timelineContainer');
      const currentDateDisplay = document.getElementById('currentDateDisplay');
      const data = itineraryData[dateStr];

      // Fade out
      timelineContainer.classList.add('fade-out');

      setTimeout(() => {
        if (!data) {
          timeline.innerHTML = '<div class="timeline-empty"><div class="timeline-empty__icon">üìÖ</div><div class="timeline-empty__text">No events scheduled</div></div>';
          currentDateDisplay.textContent = 'No date selected';
          timelineContainer.classList.remove('fade-out');
          return;
        }

        currentDateDisplay.textContent = data.date;

        if (data.events.length === 0) {
          timeline.innerHTML = '<div class="timeline-empty"><div class="timeline-empty__icon">üìÖ</div><div class="timeline-empty__text">No events scheduled for this day</div></div>';
          timelineContainer.classList.remove('fade-out');
          return;
        }

        timeline.innerHTML = data.events.map((event, index) => {
          // Determine image based on event title
          let imageHtml = '';
          if (event.title === 'Calgary Zoo') {
            imageHtml = `<img class="timeline-event__image" src="../images/calgaryZOO.png" alt="Calgary Zoo">`;
          } else if (event.title === 'Peace Bridge') {
            imageHtml = `<img class="timeline-event__image" src="../images/The_Peace_Bridge_in_Calgary_an_HDR_photo.png" alt="Peace Bridge">`;
          } else if (event.title === 'Ten Foot Henry') {
            imageHtml = `<img class="timeline-event__image" src="../images/tenfoothenry.png" alt="Ten Foot Henry">`;
          } else if (event.title === 'Avesta Shawarma') {
            imageHtml = `<img class="timeline-event__image" src="../images/avesta.png" alt="Avesta Shawarma">`;
          } else if (event.title === 'River Caf√©' || event.title === 'River Cafe') {
            imageHtml = `<img class="timeline-event__image" src="../images/riverCafe.png" alt="River Caf√©">`;
          }
          
          return `
          <div class="timeline-item" style="animation-delay: ${index * 0.1}s">
            <div class="timeline-time">${event.time}</div>
            <div class="timeline-event" onclick="window.location.href='itinerary-detail.html?date=${dateStr}&index=${index}'">
              ${imageHtml}
              <div class="timeline-event__title">${event.title}</div>
              <div class="timeline-event__details">${event.details}</div>
              <div class="timeline-event__address">${event.address}</div>
            </div>
          </div>
        `;
        }).join('');

        // Fade in
        timelineContainer.classList.remove('fade-out');
        
        // Scroll content to top (to show dates)
        const contentArea = document.querySelector('.itinerary-page.content');
        if (contentArea) {
          contentArea.scrollTop = 0;
        }
      }, 150);
    }

    // Track current active date
    let currentActiveDate = '2026-07-14';

    // Handle date selector scroll with dynamic sizing
    function handleDateScroll() {
      const dateSelector = document.getElementById('dateSelector');
      const dateTabs = Array.from(dateSelector.querySelectorAll('.date-tab'));
      const containerWidth = dateSelector.offsetWidth;
      const scrollLeft = dateSelector.scrollLeft;
      const center = scrollLeft + containerWidth / 2;

      let closestTab = null;
      let closestDistance = Infinity;

      // Calculate distances and find closest tab to center
      // Use offsetLeft for consistent coordinate system relative to scroll container
      dateTabs.forEach((tab) => {
        const tabLeft = tab.offsetLeft;
        const tabWidth = tab.offsetWidth;
        const tabCenter = tabLeft + tabWidth / 2;
        const distance = Math.abs(center - tabCenter);

        if (distance < closestDistance) {
          closestDistance = distance;
          closestTab = tab;
        }
      });

      // Apply sizes based on pixel distance from center with threshold-based sizing
      dateTabs.forEach((tab) => {
        const tabLeft = tab.offsetLeft;
        const tabWidth = tab.offsetWidth;
        const tabCenter = tabLeft + tabWidth / 2;
        const pixelDistance = Math.abs(center - tabCenter);
        
        // Define thresholds in pixels for different size levels
        const threshold1 = 60;  // Adjacent dates
        const threshold2 = 120; // Next dates
        const threshold3 = 180; // Further dates
        
        let scale, opacity, minWidth, maxWidth, padding, dayFontSize, monthFontSize;
        
        // Remove active class first
        tab.classList.remove('active');
        
        if (pixelDistance < 30) {
          // Center date - largest (within 30px of center)
          scale = 1.15;
          opacity = 1;
          minWidth = 65;
          maxWidth = 75;
          padding = 'var(--spacing-sm) var(--spacing-md)';
          dayFontSize = '18px';
          monthFontSize = '12px';
          tab.classList.add('active');
        } else if (pixelDistance < threshold1) {
          // Adjacent dates (13th, 15th) - medium-large
          scale = 0.95;
          opacity = 0.85;
          minWidth = 55;
          maxWidth = 65;
          padding = 'var(--spacing-sm) var(--spacing-md)';
          dayFontSize = '16px';
          monthFontSize = '11px';
        } else if (pixelDistance < threshold2) {
          // Next dates (12th, 16th) - medium
          scale = 0.85;
          opacity = 0.7;
          minWidth = 50;
          maxWidth = 58;
          padding = 'var(--spacing-xs) var(--spacing-sm)';
          dayFontSize = '14px';
          monthFontSize = '10px';
        } else if (pixelDistance < threshold3) {
          // Further dates (11th, 17th) - small
          scale = 0.75;
          opacity = 0.6;
          minWidth = 45;
          maxWidth = 52;
          padding = 'var(--spacing-xs) var(--spacing-sm)';
          dayFontSize = '13px';
          monthFontSize = '9px';
        } else {
          // Furthest dates - smallest
          scale = 0.7;
          opacity = 0.5;
          minWidth = 42;
          maxWidth = 48;
          padding = 'var(--spacing-xs) var(--spacing-sm)';
          dayFontSize = '12px';
          monthFontSize = '8px';
        }
        
        // Apply styles to tab
        tab.style.transform = `scale(${scale})`;
        tab.style.opacity = opacity;
        tab.style.minWidth = `${minWidth}px`;
        tab.style.maxWidth = `${maxWidth}px`;
        tab.style.padding = padding;
        
        // Apply font sizes to day and month
        const dayElement = tab.querySelector('.date-tab__day');
        const monthElement = tab.querySelector('.date-tab__month');
        if (dayElement) {
          dayElement.style.fontSize = dayFontSize;
        }
        if (monthElement) {
          monthElement.style.fontSize = monthFontSize;
        }
      });

      // Update timeline if date changed
      if (closestTab) {
        const selectedDate = closestTab.dataset.date;
        if (selectedDate !== currentActiveDate) {
          currentActiveDate = selectedDate;
          updateTimeline(selectedDate);
        }
      }
    }

    // Update sticky position for current date display based on date selector height
    function updateStickyPosition() {
      const dateSelectorWrapper = document.querySelector('.date-selector-wrapper');
      const currentDateDisplay = document.querySelector('.current-date-display');
      
      if (dateSelectorWrapper && currentDateDisplay) {
        const dateSelectorHeight = dateSelectorWrapper.offsetHeight;
        currentDateDisplay.style.top = `${dateSelectorHeight}px`;
      }
    }

    // Check for pending undo and show notification
    function checkPendingUndo() {
      try {
        const pendingUndo = sessionStorage.getItem('pendingUndo');
        if (pendingUndo) {
          deletedEventInfo = JSON.parse(pendingUndo);
          showUndoNotification();
          
          // Auto-hide notification after 5 seconds
          if (undoTimeout) {
            clearTimeout(undoTimeout);
          }
          undoTimeout = setTimeout(() => {
            hideUndoNotification();
            sessionStorage.removeItem('pendingUndo');
            deletedEventInfo = null;
          }, 5000);
        }
      } catch (e) {
        console.error('Error checking pending undo:', e);
      }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      generateDates();
      setupUndoButton();
      checkPendingUndo();
      
      const dateSelector = document.getElementById('dateSelector');
      
      // Update sticky position after dates are generated
      setTimeout(() => {
        updateStickyPosition();
        
        // Scroll to initial active date (July 14th - index 3)
        const dateTabs = Array.from(dateSelector.querySelectorAll('.date-tab'));
        const activeTab = dateTabs.find(tab => tab.dataset.date === '2026-07-14') || dateTabs[3];
        if (activeTab) {
          const containerWidth = dateSelector.offsetWidth;
          const scrollPosition = activeTab.offsetLeft - (containerWidth / 2) + (activeTab.offsetWidth / 2);
          dateSelector.scrollTo({
            left: scrollPosition,
            behavior: 'auto' // Use 'auto' for instant scroll on load
          });
          
          // Update sizes after scroll
          setTimeout(() => {
            handleDateScroll();
          }, 50);
        }
      }, 200);
      
      // Update sticky position on window resize
      window.addEventListener('resize', updateStickyPosition);

      // Handle scroll events - update on every scroll for smooth animation
      let scrollTimeout;
      dateSelector.addEventListener('scroll', () => {
        // Update immediately for smooth scrolling
        handleDateScroll();
        
        // Also update after scroll ends for final positioning
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          handleDateScroll();
        }, 100);
      }, { passive: true });

      // Handle touch end for snap scrolling
      dateSelector.addEventListener('touchend', () => {
        setTimeout(() => {
          // Find closest tab to center
          const dateTabs = Array.from(dateSelector.querySelectorAll('.date-tab'));
          const containerWidth = dateSelector.offsetWidth;
          const scrollLeft = dateSelector.scrollLeft;
          const center = scrollLeft + containerWidth / 2;

          let closestTab = null;
          let closestDistance = Infinity;

          dateTabs.forEach((tab) => {
            const tabLeft = tab.offsetLeft;
            const tabWidth = tab.offsetWidth;
            const tabCenter = tabLeft + tabWidth / 2;
            const distance = Math.abs(center - tabCenter);

            if (distance < closestDistance) {
              closestDistance = distance;
              closestTab = tab;
            }
          });

          // Snap to closest tab and update date immediately
          if (closestTab) {
            const selectedDate = closestTab.dataset.date;
            // Update date immediately
            if (selectedDate && selectedDate !== currentActiveDate) {
              currentActiveDate = selectedDate;
              updateTimeline(selectedDate);
            }
            
            const scrollPosition = closestTab.offsetLeft - (containerWidth / 2) + (closestTab.offsetWidth / 2);
            dateSelector.scrollTo({
              left: scrollPosition,
              behavior: 'smooth'
            });
          }
          
          // Update sizes after snap
          setTimeout(() => {
            handleDateScroll();
          }, 150);
        }, 100);
      }, { passive: true });

      // Handle click on date tabs
      dateSelector.addEventListener('click', (e) => {
        const dateTab = e.target.closest('.date-tab');
        if (dateTab) {
          const selectedDate = dateTab.dataset.date;
          // Update date immediately
          if (selectedDate && selectedDate !== currentActiveDate) {
            currentActiveDate = selectedDate;
            updateTimeline(selectedDate);
          }
          
          const containerWidth = dateSelector.offsetWidth;
          const scrollPosition = dateTab.offsetLeft - (containerWidth / 2) + (dateTab.offsetWidth / 2);
          dateSelector.scrollTo({
            left: scrollPosition,
            behavior: 'smooth'
          });
          
          // Update sizes after scroll
          setTimeout(() => {
            handleDateScroll();
          }, 300);
        }
      });

      // Update on scroll animation end (if browser supports it)
      if ('onscrollend' in dateSelector) {
        dateSelector.addEventListener('scrollend', handleDateScroll);
      }
    });


    // Check for time conflicts
    function checkTimeConflict(dateStr, startTime, endTime, excludeIndex = -1) {
      const events = itineraryData[dateStr].events;
      const conflicts = [];
      
      const start = parseTime(startTime);
      const end = parseTime(endTime);
      
      events.forEach((event, index) => {
        if (index === excludeIndex) return; // Skip the event being edited
        
        const [eventStartStr, eventEndStr] = event.details.split(' - ');
        const eventStart = parseTime(eventStartStr);
        const eventEnd = parseTime(eventEndStr);
        
        // Check for overlap
        if ((start >= eventStart && start < eventEnd) ||
            (end > eventStart && end <= eventEnd) ||
            (start <= eventStart && end >= eventEnd)) {
          conflicts.push({
            title: event.title,
            time: event.details
          });
        }
      });
      
      return conflicts;
    }

    // Parse time string to minutes since midnight
    function parseTime(timeStr) {
      const [hours, minutes] = timeStr.split(':').map(Number);
      return hours * 60 + minutes;
    }

    // Format time from minutes to HH:MM
    function formatTime(minutes) {
      const hours = Math.floor(minutes / 60);
      const mins = minutes % 60;
      return `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}`;
    }

    // Add new event
    function addEvent(dateStr, eventData) {
      if (!itineraryData[dateStr]) {
        // Create date entry if it doesn't exist
        const date = new Date(dateStr + 'T00:00:00');
        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        itineraryData[dateStr] = {
          date: `${dayNames[date.getDay()]} - ${monthNames[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`,
          events: []
        };
      }
      
      // Check for conflicts before adding
      const conflicts = checkTimeConflict(dateStr, eventData.startTime, eventData.endTime);
      
      if (conflicts.length > 0) {
        return {
          success: false,
          conflicts: conflicts
        };
      }
      
      // Add event in sorted order by time
      const newEvent = {
        time: eventData.startTime,
        title: eventData.title,
        details: `${eventData.startTime} - ${eventData.endTime}`,
        address: eventData.address
      };
      
      itineraryData[dateStr].events.push(newEvent);
      itineraryData[dateStr].events.sort((a, b) => {
        const timeA = parseTime(a.time);
        const timeB = parseTime(b.time);
        return timeA - timeB;
      });
      
      // Update display
      updateTimeline(dateStr);
      saveItineraryData();
      
      return {
        success: true,
        conflicts: []
      };
    }

    // Update event
    function updateEvent(dateStr, eventIndex, updatedEvent) {
      const conflicts = checkTimeConflict(dateStr, updatedEvent.startTime, updatedEvent.endTime, eventIndex);
      
      if (conflicts.length > 0) {
        return {
          success: false,
          conflicts: conflicts
        };
      }
      
      itineraryData[dateStr].events[eventIndex] = {
        time: updatedEvent.startTime,
        title: updatedEvent.title,
        details: `${updatedEvent.startTime} - ${updatedEvent.endTime}`,
        address: updatedEvent.address
      };
      
      // Re-sort events
      itineraryData[dateStr].events.sort((a, b) => {
        const timeA = parseTime(a.time);
        const timeB = parseTime(b.time);
        return timeA - timeB;
      });
      
      // Update display
      updateTimeline(dateStr);
      saveItineraryData();
      
      return {
        success: true,
        conflicts: []
      };
    }

    // Reload data from sessionStorage on page visibility change (when coming back from edit)
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        try {
          const saved = sessionStorage.getItem('itineraryData');
          if (saved) {
            const savedData = JSON.parse(saved);
            // Merge saved data with current data
            Object.keys(savedData).forEach(date => {
              itineraryData[date] = savedData[date];
            });
            // Refresh the timeline if we're viewing a date that was edited
            if (itineraryData[currentActiveDate]) {
              updateTimeline(currentActiveDate);
            }
          }
        } catch (e) {
          console.error('Error loading saved itinerary data:', e);
        }
      }
    });
    
    // Also reload on page focus (for better compatibility)
    window.addEventListener('focus', () => {
      try {
        const saved = sessionStorage.getItem('itineraryData');
        if (saved) {
          const savedData = JSON.parse(saved);
          Object.keys(savedData).forEach(date => {
            itineraryData[date] = savedData[date];
          });
          if (itineraryData[currentActiveDate]) {
            updateTimeline(currentActiveDate);
          }
        }
      } catch (e) {
        console.error('Error loading saved itinerary data:', e);
      }
    });

    // Store deleted event info for undo
    let deletedEventInfo = null;
    let undoTimeout = null;


    // Show undo notification
    function showUndoNotification() {
      const notification = document.getElementById('undoNotification');
      notification.classList.add('show');
    }

    // Hide undo notification
    function hideUndoNotification() {
      const notification = document.getElementById('undoNotification');
      notification.classList.remove('show');
      setTimeout(() => {
        deletedEventInfo = null;
      }, 300);
    }

    // Undo delete function
    function undoDelete() {
      if (!deletedEventInfo) {
        return;
      }

      const { dateStr, eventIndex, event } = deletedEventInfo;

      // Ensure date entry exists
      if (!itineraryData[dateStr]) {
        const date = new Date(dateStr + 'T00:00:00');
        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        itineraryData[dateStr] = {
          date: `${dayNames[date.getDay()]} - ${monthNames[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`,
          events: []
        };
      }

      // Insert event back at original position
      itineraryData[dateStr].events.splice(eventIndex, 0, event);

      // Re-sort events by time
      itineraryData[dateStr].events.sort((a, b) => {
        const timeA = parseTime(a.time);
        const timeB = parseTime(b.time);
        return timeA - timeB;
      });

      // Update display
      updateTimeline(dateStr);
      saveItineraryData();

      // Hide notification
      hideUndoNotification();

      // Clear undo timeout
      if (undoTimeout) {
        clearTimeout(undoTimeout);
        undoTimeout = null;
      }

      // Clear pending undo from sessionStorage
      sessionStorage.removeItem('pendingUndo');
    }

    // Setup undo button listener (will be called in DOMContentLoaded)
    function setupUndoButton() {
      const undoButton = document.getElementById('undoButton');
      if (undoButton) {
        undoButton.onclick = undoDelete;
      }
    }
  </script>
</body>
</html>
